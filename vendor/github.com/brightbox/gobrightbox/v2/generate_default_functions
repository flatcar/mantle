#!/usr/bin/env ruby
# frozen_string_literal: true

# Generate Default Command and Tests from supplied yaml file

require 'yaml'

def generate_default_tested_api_commands(struct, options)
  file_prefix = options['path'].downcase
  generate_default_api_commands(struct, options, "#{file_prefix}_default.go")
  generate_default_test_commands(struct, options, "#{file_prefix}_default_test.go")
  %W[#{file_prefix}_default.go #{file_prefix}_default_test.go]
end

def generate_default_api_commands(struct, options, output_filename)
  plural = options['plural'] || "#{struct}s"
  File.open(output_filename, 'w') do |f|
    f << file_header
    f << "import \"fmt\"\n\n" if options['crud'].include?('handle')
    f << path_constant(struct, options['path'])
    f << collection_function(struct, plural)
    f << instance_function(struct)
    f << instance_by_handle_function(struct, plural) if options['crud'].include?('handle')
    f << create_function(struct) if options['crud'].include?('create')
    f << update_function(struct) if options['crud'].include?('update')
    f << destroy_function(struct) if options['crud'].include?('delete')
    f << lock_functions(struct) if options['crud'].include?('lock')
    f << created_at_function(struct) if options['crud'].include?('createdate')
    f << reset_password_function(struct, options['password']) if options['password']
    f << resize_function(struct) if options['crud'].include?('resize')
    f << simple_function(struct, 'reset') if options['crud'].include?('reset')
  end
end

def generate_default_test_commands(struct, options, output_filename)
  plural = options['plural'] || "#{struct}s"
  File.open(output_filename, 'w') do |f|
    f << test_file_header(options)
    f << test_collection_function(struct, plural, options)
    f << test_instance_function(struct, options)
    f << test_instance_by_handle_function(struct, options) if options['crud'].include?('handle')
    f << test_create_function(struct, options) if options['crud'].include?('create')
    f << test_update_function(struct, options) if options['crud'].include?('update')
    f << test_destroy_function(struct, options) if options['crud'].include?('delete')
    f << test_lock_functions(struct, options) if options['crud'].include?('lock')
    f << test_created_at_function(struct) if options['crud'].include?('createdate')
    f << test_reset_password_function(struct, options) if options['password']
    f << test_resize_function(struct, options) if options['crud'].include?('resize')
    f << test_simple_function(struct, options, 'reset') if options['crud'].include?('reset')
  end
end

def test_file_header(options)
  <<~ENDFUNC
    // Code generated by go generate; DO NOT EDIT.

    package brightbox

    import (
      "path"
      "testing"
      #{options['crud'].include?('createdate') ? '"time"' : ''}

      "gotest.tools/v3/assert"
    )

  ENDFUNC
end

def test_collection_function(struct, plural, options)
  <<~ENDFUNC
    func Test#{plural}(t *testing.T) {
      instance := testAll(
        t,
        (*Client).#{plural},
        "#{struct}",
        "#{options['path']}",
        "#{plural}",
      )
      assert.Equal(t, instance.ID, "#{options['testid']}")
    }

  ENDFUNC
end

def test_instance_function(struct, options)
  <<~ENDFUNC
    func Test#{struct}(t *testing.T) {
      instance := testInstance(
        t,
        (*Client).#{struct},
        "#{struct}",
        path.Join("#{options['path']}", "#{options['testid']}"),
        "#{options['jsonpath']}",
        "#{options['testid']}",
      )
      assert.Equal(t, instance.ID, "#{options['testid']}")
    }

  ENDFUNC
end

def test_instance_by_handle_function(struct, options)
  <<~ENDFUNC
    func Test#{struct}ByHandle(t *testing.T) {
      instance := testInstance(
        t,
        (*Client).#{struct},
        "#{struct}",
        path.Join("#{options['path']}", "#{options['testid']}"),
        "#{options['jsonpath']}",
        "#{options['testid']}",
      )
      assert.Equal(t, instance.ID, "#{options['testid']}")
      handleInstance := testInstance[#{struct}](
        t,
        (*Client).#{struct}ByHandle,
        "#{struct}",
        path.Join("#{options['path']}"),
        "#{options['path']}",
        instance.Handle,
      )
      assert.Equal(t, instance.ID, handleInstance.ID)
    }

  ENDFUNC
end

def test_resize_function(struct, options)
  <<~GO
    func TestResize#{struct}(t *testing.T) {
      instance := testLink(
        t,
        (*Client).Resize#{struct},
        "#{options['testid']}",
        #{struct}NewSize{#{options['resize_request']}},
        "#{options['jsonpath']}",
        "POST",
        path.Join("#{options['path']}", "#{options['testid']}", "resize"),
        `#{options['resize_response']}`,
      )
      assert.Equal(t, instance.ID, "#{options['testid']}")
    }

  GO
end

def test_create_function(struct, options)
  <<~ENDFUNC
    func TestCreate#{struct}(t *testing.T) {
      newResource := #{struct}Options{}
      instance := testModify(
        t,
        (*Client).Create#{struct},
        newResource,
        "#{options['jsonpath']}",
        "POST",
        path.Join("#{options['path']}"),
        "{}",
      )
      assert.Equal(t, instance.ID, "#{options['testid']}")
    }

  ENDFUNC
end

def test_update_function(struct, options)
  <<~ENDFUNC
    func TestUpdate#{struct}(t *testing.T) {
      updatedResource := #{struct}Options{ID: "#{options['testid']}"}
      instance := testModify(
        t,
        (*Client).Update#{struct},
        updatedResource,
        "#{options['jsonpath']}",
        "PUT",
        path.Join("#{options['path']}", updatedResource.ID),
        "{}",
      )
      assert.Equal(t, instance.ID, updatedResource.ID)
    }

  ENDFUNC
end

def test_destroy_function(struct, options)
  <<~ENDFUNC
    func TestDestroy#{struct}(t *testing.T) {
      deletedResource := testModify(
        t,
        (*Client).Destroy#{struct},
        "#{options['testid']}",
        "#{options['jsonpath']}",
        "DELETE",
        path.Join("#{options['path']}", "#{options['testid']}"),
        "",
      )
      assert.Equal(t, deletedResource.ID, "#{options['testid']}")
    }

  ENDFUNC
end

def test_lock_functions(struct, options)
  <<~ENDFUNC
    func TestLock#{struct}(t *testing.T) {
      lockedResource := testModify(
        t,
        (*Client).Lock#{struct},
        "#{options['testid']}",
        "#{options['jsonpath']}",
        "PUT",
        path.Join("#{options['path']}", "#{options['testid']}", "lock_resource"),
        "",
      )
      assert.Equal(t, lockedResource.ID, "#{options['testid']}")
    }

    func TestUnlock#{struct}(t *testing.T) {
      unlockedResource := testModify(
        t,
        (*Client).Unlock#{struct},
        "#{options['testid']}",
        "#{options['jsonpath']}",
        "PUT",
        path.Join("#{options['path']}", "#{options['testid']}", "unlock_resource"),
        "",
      )
      assert.Equal(t, unlockedResource.ID, "#{options['testid']}")
    }

  ENDFUNC
end

def test_created_at_function(struct)
  <<~ENDFUNC

    func Test#{struct}CreatedAtUnix(t *testing.T) {
      tm := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
      target := #{struct}{CreatedAt: &tm}
      assert.Equal(t, target.CreatedAtUnix(), tm.Unix())
    }

  ENDFUNC
end

def test_reset_password_function(struct, options)
  <<~ENDFUNC
    func TestReset#{struct}Password(t *testing.T) {
      instance := testModify(
        t,
        (*Client).Reset#{struct}Password,
        "#{options['testid']}",
        "#{options['jsonpath']}",
        "POST",
        path.Join("#{options['path']}", "#{options['testid']}", "#{options['password']}"),
        "",
      )
      assert.Equal(t, instance.ID, "#{options['testid']}")
    }

  ENDFUNC
end

def test_simple_function(struct, options, function)
  function_name = "#{function.capitalize}#{struct}"

  <<~ENDFUNC
    func Test#{function_name}(t *testing.T) {
      instance := testModify(
        t,
        (*Client).#{function_name},
        "#{options['testid']}",
        "#{options['jsonpath']}",
        "POST",
        path.Join("#{options['path']}", "#{options['testid']}", "#{function}"),
        "",
      )
      assert.Equal(t, instance.ID, "#{options['testid']}")
    }

  ENDFUNC
end

def file_header
  <<~ENDFUNC
    // Code generated by go generate; DO NOT EDIT.

    package brightbox

    import "context"
    import "path"

  ENDFUNC
end

def path_constant(struct, pathname)
  <<~ENDFUNC
    const (
      // #{struct.downcase}APIPath returns the relative URL path to the #{struct} endpoint
      #{struct.downcase}APIPath = "#{pathname}"
    )

  ENDFUNC
end

def collection_function(struct, plural)
  <<~ENDFUNC
    // #{plural} returns the collection view for #{struct}
    func (c *Client) #{plural}(ctx context.Context) ([]#{struct}, error) {
      return apiGetCollection[[]#{struct}](ctx, c, #{struct.downcase}APIPath)
    }

  ENDFUNC
end

def instance_function(struct)
  <<~ENDFUNC
    // #{struct} retrieves a detailed view of one resource
    func (c *Client) #{struct}(ctx context.Context, identifier string) (*#{struct}, error) {
      return apiGet[#{struct}](ctx, c, path.Join(#{struct.downcase}APIPath, identifier))
    }

  ENDFUNC
end

def instance_by_handle_function(struct, plural)
  <<~ENDFUNC

    // #{struct} retrieves a detailed view of one resource using a handle
    func (c *Client) #{struct}ByHandle(ctx context.Context, handle string) (*#{struct}, error) {
      collection, err := c.#{plural}(ctx)
      if err != nil {
        return nil, err
      }
      for _, instance := range collection {
        if instance.Handle == handle {
          return &instance, nil
        }
      }
      return nil, fmt.Errorf("Resource with handle '%s' doesn't exist", handle)
    }

  ENDFUNC
end

def create_function(struct)
  <<~ENDFUNC
    // Create#{struct} creates a new resource from the supplied option map.
    //
    // It takes an instance of #{struct}Options. Not all attributes can be
    // specified at create time (such as ID, which is allocated for you).
    func (c *Client) Create#{struct}(ctx context.Context, new#{struct} #{struct}Options) (*#{struct}, error) {
      return apiPost[#{struct}](ctx, c, #{struct.downcase}APIPath, new#{struct})
    }

  ENDFUNC
end

def update_function(struct)
  <<~ENDFUNC
    // Update#{struct} updates an existing resources's attributes. Not all
    // attributes can be changed (such as ID).
    //
    // It takes an instance of #{struct}Options. Specify the resource you
    // want to update using the ID field.
    func (c *Client) Update#{struct}(ctx context.Context, update#{struct} #{struct}Options) (*#{struct}, error) {
      return apiPut[#{struct}](ctx, c, path.Join(#{struct.downcase}APIPath, update#{struct}.ID), update#{struct})
    }

  ENDFUNC
end

def resize_function(struct)
  function_name = "Resize#{struct}"
  size_type = "#{struct}NewSize"
  <<~GO
    // #{function_name} issues a request to change the server type of a server
    // changing the amount of cpu and ram it has.
    func (c *Client) #{function_name}(ctx context.Context, identifier string, newSize #{size_type}) (*#{struct}, error) {
      return apiPost[#{struct}](ctx, c, path.Join(#{struct.downcase}APIPath, identifier, "resize"), newSize)
    }

  GO
end

def destroy_function(struct)
  <<~ENDFUNC
    // Destroy#{struct} destroys an existing resource.
    func (c *Client) Destroy#{struct}(ctx context.Context, identifier string) (*#{struct}, error) {
      return apiDelete[#{struct}](ctx, c, path.Join(#{struct.downcase}APIPath, identifier))
    }

  ENDFUNC
end

def lock_functions(struct)
  <<~ENDFUNC
    // Lock#{struct} locks a resource against destroy requests
    func (c *Client) Lock#{struct}(ctx context.Context, identifier string) (*#{struct}, error) {
      return apiPut[#{struct}](ctx, c, path.Join(#{struct.downcase}APIPath, identifier, "lock_resource"), nil)
    }

    // Unlock#{struct} unlocks a resource, re-enabling destroy requests
    func (c *Client) Unlock#{struct}(ctx context.Context, identifier string) (*#{struct}, error) {
      return apiPut[#{struct}](ctx, c, path.Join(#{struct.downcase}APIPath, identifier, "unlock_resource"), nil)
    }
  ENDFUNC
end

def created_at_function(struct)
  <<~ENDFUNC
    // CreatedAt implements the CreateDated interface for #{struct}
    func (s #{struct}) CreatedAtUnix() int64 {
      return s.CreatedAt.Unix()
    }

  ENDFUNC
end

def reset_password_function(struct, endpoint)
  <<~ENDFUNC
    // Reset#{struct}Password resets the password in #{struct}, returning it 
    // in the returned resource. This is the only time the new password is
    // available in plaintext.
    func (c *Client) Reset#{struct}Password(ctx context.Context, identifier string) (*#{struct}, error) {
      return apiPost[#{struct}](ctx, c, path.Join(#{struct.downcase}APIPath, identifier, "#{endpoint}"), nil)
    }

  ENDFUNC
end

def simple_function(struct, endpoint)
  function_name = "#{endpoint.capitalize}#{struct}"
  <<~GO
    // #{function_name} issues a "#{endpoint}" instruction to a #{struct}
    func (c *Client) #{function_name}(ctx context.Context, identifier string) (*#{struct}, error) {
    return apiPost[#{struct}](ctx, c, path.Join(#{struct.downcase}APIPath, identifier, "#{endpoint}"), nil)
    }
  GO
end

object_hash = YAML.safe_load(ARGF.read)
files = %w[gofmt -w]
object_hash.each { |k, v| files << generate_default_tested_api_commands(k, v) }
exec(*files.flatten)
