// Code generated by generate_enum; DO NOT EDIT.

// Package volumestatus is an enumeration of the states Creating, Attached, Detached, Deleting, Deleted, Failed
package volumestatus

import (
	"encoding/json"
	"fmt"
	"reflect"
)

// Enum is an enumerated type
type Enum uint8

const (
	// Creating is an enumeration for volumestatus.Enum
	Creating Enum = iota + 1
	// Attached is an enumeration for volumestatus.Enum
	Attached
	// Detached is an enumeration for volumestatus.Enum
	Detached
	// Deleting is an enumeration for volumestatus.Enum
	Deleting
	// Deleted is an enumeration for volumestatus.Enum
	Deleted
	// Failed is an enumeration for volumestatus.Enum
	Failed
)

// ValidStrings is the set of strings that are valid inputs to ParseEnum
var ValidStrings = []string{
	Creating.String(),
	Attached.String(),
	Detached.String(),
	Deleting.String(),
	Deleted.String(),
	Failed.String(),
}

// String makes Enum satisfy the Stringer interface
func (i Enum) String() string {
	tmp, err := i.MarshalText()
	if err == nil {
		return string(tmp)
	}
	return ""
}

// ParseEnum attempts to convert a string into a Enum
func ParseEnum(name string) (Enum, error) {
	switch name {
	case "creating":
		return Creating, nil
	case "attached":
		return Attached, nil
	case "detached":
		return Detached, nil
	case "deleting":
		return Deleting, nil
	case "deleted":
		return Deleted, nil
	case "failed":
		return Failed, nil
	}
	var zero Enum
	return zero, fmt.Errorf("%s is not a valid volumestatus.Enum", name)
}

// MarshalText implements the text marshaller method
func (i Enum) MarshalText() ([]byte, error) {
	switch i {
	case Creating:
		return []byte("creating"), nil
	case Attached:
		return []byte("attached"), nil
	case Detached:
		return []byte("detached"), nil
	case Deleting:
		return []byte("deleting"), nil
	case Deleted:
		return []byte("deleted"), nil
	case Failed:
		return []byte("failed"), nil
	}
	return nil, fmt.Errorf("%d is not a valid volumestatus.Enum", i)
}

// UnmarshalText implements the text unmarshaller method
func (i *Enum) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseEnum(name)
	if err != nil {
		return &json.UnmarshalTypeError{
			Value: name,
			Type:  reflect.TypeOf(*i),
		}
	}
	*i = tmp
	return nil
}
