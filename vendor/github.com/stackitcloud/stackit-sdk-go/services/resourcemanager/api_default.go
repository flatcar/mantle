/*
Resource Manager API

API v2 to manage resource containers - organizations, folders, projects incl. labels  ### Resource Management STACKIT resource management handles the terms _Organization_, _Folder_, _Project_, _Label_, and the hierarchical structure between them. Technically, organizations,  folders, and projects are _Resource Containers_ to which a _Label_ can be attached to. The STACKIT _Resource Manager_ provides CRUD endpoints to query and to modify the state.  ### Organizations STACKIT organizations are the base element to create and to use cloud-resources. An organization is bound to one customer account. Organizations have a lifecycle. - Organizations are always the root node in resource hierarchy and do not have a parent  ### Projects STACKIT projects are needed to use cloud-resources. Projects serve as wrapper for underlying technical structures and processes. Projects have a lifecycle. Projects compared to folders may have different policies. - Projects are optional, but mandatory for cloud-resource usage - A project can be created having either an organization, or a folder as parent - A project must not have a project as parent - Project names under the same parent must not be unique - Root organization cannot be changed  ### Label STACKIT labels are key-value pairs including a resource container reference. Labels can be defined and attached freely to resource containers by which resources can be organized and queried. - Policy-based, immutable labels may exists

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package resourcemanager

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
	"time"

	"github.com/stackitcloud/stackit-sdk-go/core/config"
	"github.com/stackitcloud/stackit-sdk-go/core/oapierror"
)

type DefaultApi interface {
	/*
		CreateFolder Create Folder
		Create a new folder.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateFolderRequest
	*/
	CreateFolder(ctx context.Context) ApiCreateFolderRequest
	/*
		CreateFolderExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return FolderResponse

	*/
	CreateFolderExecute(ctx context.Context) (*FolderResponse, error)
	/*
		CreateProject Create Project
		Create a new project.
		- The request is synchronous, but the workflow-based creation is asynchronous.
		- Lifecycle state remains in CREATING, until workflow completes

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateProjectRequest
	*/
	CreateProject(ctx context.Context) ApiCreateProjectRequest
	/*
		CreateProjectExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return Project

	*/
	CreateProjectExecute(ctx context.Context) (*Project, error)
	/*
		DeleteFolder Delete Folder
		Delete a folder and its metadata.
		- Folder must not be parent of any other container
		- A force flag may be set, deleting all underlying folders recursively - if no project is attached!

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param containerId Folder identifier - containerId as well as UUID identifier is supported.
		@return ApiDeleteFolderRequest
	*/
	DeleteFolder(ctx context.Context, containerId string) ApiDeleteFolderRequest
	/*
		DeleteFolderExecute executes the request

	*/
	DeleteFolderExecute(ctx context.Context, containerId string) error
	/*
		DeleteFolderLabels Delete Folder Labels
		Deletes all folder labels by given keys.
		- Specific labels may be deleted by key(s)
		- If no key is specified, all labels will be deleted!

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param containerId Folder identifier - containerId as well as UUID identifier is supported.
		@return ApiDeleteFolderLabelsRequest
	*/
	DeleteFolderLabels(ctx context.Context, containerId string) ApiDeleteFolderLabelsRequest
	/*
		DeleteFolderLabelsExecute executes the request

	*/
	DeleteFolderLabelsExecute(ctx context.Context, containerId string) error
	/*
		DeleteOrganizationLabels Delete Organization Labels
		Deletes all organization labels by given keys.
		- Specific labels may be deleted by key(s)
		- If no key is specified, all labels will be deleted!

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param containerId Organization identifier - containerId as well as UUID identifier is supported.
		@return ApiDeleteOrganizationLabelsRequest
	*/
	DeleteOrganizationLabels(ctx context.Context, containerId string) ApiDeleteOrganizationLabelsRequest
	/*
		DeleteOrganizationLabelsExecute executes the request

	*/
	DeleteOrganizationLabelsExecute(ctx context.Context, containerId string) error
	/*
		DeleteProject Delete Project
		Triggers the deletion of a project.
		- The request is synchronous, but the workflow-based deletion is asynchronous
		- Lifecycle state remains in DELETING, until workflow completes

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Project identifier - containerId as well as UUID identifier is supported.
		@return ApiDeleteProjectRequest
	*/
	DeleteProject(ctx context.Context, id string) ApiDeleteProjectRequest
	/*
		DeleteProjectExecute executes the request

	*/
	DeleteProjectExecute(ctx context.Context, id string) error
	/*
		DeleteProjectLabels Delete Project Labels
		Deletes all project labels by given keys.
		- Specific labels may be deleted by key(s)
		- If no key is specified, all labels will be deleted!

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param containerId Project identifier - containerId as well as UUID identifier is supported.
		@return ApiDeleteProjectLabelsRequest
	*/
	DeleteProjectLabels(ctx context.Context, containerId string) ApiDeleteProjectLabelsRequest
	/*
		DeleteProjectLabelsExecute executes the request

	*/
	DeleteProjectLabelsExecute(ctx context.Context, containerId string) error
	/*
		GetFolderDetails Get Folder Details
		Returns all metadata for a specific folder.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param containerId Folder identifier - containerId as well as UUID identifier is supported.
		@return ApiGetFolderDetailsRequest
	*/
	GetFolderDetails(ctx context.Context, containerId string) ApiGetFolderDetailsRequest
	/*
		GetFolderDetailsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param containerId Folder identifier - containerId as well as UUID identifier is supported.
		@return GetFolderDetailsResponse

	*/
	GetFolderDetailsExecute(ctx context.Context, containerId string) (*GetFolderDetailsResponse, error)
	/*
		GetOrganization Get Organization Details
		Returns the organization and its metadata.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Organization identifier - containerId as well as UUID identifier is supported.
		@return ApiGetOrganizationRequest
	*/
	GetOrganization(ctx context.Context, id string) ApiGetOrganizationRequest
	/*
		GetOrganizationExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Organization identifier - containerId as well as UUID identifier is supported.
		@return OrganizationResponse

	*/
	GetOrganizationExecute(ctx context.Context, id string) (*OrganizationResponse, error)
	/*
		GetProject Get Project Details
		Returns the project and its metadata.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Project identifier - containerId as well as UUID identifier is supported.
		@return ApiGetProjectRequest
	*/
	GetProject(ctx context.Context, id string) ApiGetProjectRequest
	/*
		GetProjectExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Project identifier - containerId as well as UUID identifier is supported.
		@return GetProjectResponse

	*/
	GetProjectExecute(ctx context.Context, id string) (*GetProjectResponse, error)
	/*
		ListFolders Get All Folders
		Returns all folders and their metadata that:
		- Are children of the specific containerParentId
		- Match the given containerIds
		- User is member of <br />

		Filter:
		- Either containerParentId OR containerIds OR member must be passed
		- If containerId and containerParentId are given, both are used for filtering - containers must point to the same parent
		- If member and containerParentId are given, both are used for filtering
		- If member is given, containers must not point to the same container parent


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListFoldersRequest
	*/
	ListFolders(ctx context.Context) ApiListFoldersRequest
	/*
		ListFoldersExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ListFoldersResponse

	*/
	ListFoldersExecute(ctx context.Context) (*ListFoldersResponse, error)
	/*
		ListOrganizations Get All Organizations
		Returns all organizations and their metadata.
		- If no containerIds are specified, all organizations are returned, if permitted
		- ContainerIds may be set to filter
		- Member may be set to filter
		- If member and containerIds are given, both are used for filtering


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListOrganizationsRequest
	*/
	ListOrganizations(ctx context.Context) ApiListOrganizationsRequest
	/*
		ListOrganizationsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ListOrganizationsResponse

	*/
	ListOrganizationsExecute(ctx context.Context) (*ListOrganizationsResponse, error)
	/*
		ListProjects Get All Projects
		Returns all projects and their metadata that:
		- Are children of the specific containerParentId
		- Match the given containerIds
		- User is member of

		Filter:
		- Either containerParentId OR containerIds OR member must be passed
		- If containerId and containerParentId are given, both are used for filtering - containers must point to the same parent
		- If member and containerParentId are given, both are used for filtering
		- If member is given, containers must not point to the same container parent

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListProjectsRequest
	*/
	ListProjects(ctx context.Context) ApiListProjectsRequest
	/*
		ListProjectsExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ListProjectsResponse

	*/
	ListProjectsExecute(ctx context.Context) (*ListProjectsResponse, error)
	/*
		PartialUpdateFolder Update Folder
		Update the folder and its metadata.
		- Update folder name
		- Update folder labels
		- Update folder parent (folder or organization)

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param containerId Folder identifier - containerId as well as UUID identifier is supported.
		@return ApiPartialUpdateFolderRequest
	*/
	PartialUpdateFolder(ctx context.Context, containerId string) ApiPartialUpdateFolderRequest
	/*
		PartialUpdateFolderExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param containerId Folder identifier - containerId as well as UUID identifier is supported.
		@return FolderResponse

	*/
	PartialUpdateFolderExecute(ctx context.Context, containerId string) (*FolderResponse, error)
	/*
		PartialUpdateOrganization Update Organization
		Update the organization and its metadata.
		- Update organization name
		- Update organization labels

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Organization identifier - containerId as well as UUID identifier is supported.
		@return ApiPartialUpdateOrganizationRequest
	*/
	PartialUpdateOrganization(ctx context.Context, id string) ApiPartialUpdateOrganizationRequest
	/*
		PartialUpdateOrganizationExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Organization identifier - containerId as well as UUID identifier is supported.
		@return OrganizationResponse

	*/
	PartialUpdateOrganizationExecute(ctx context.Context, id string) (*OrganizationResponse, error)
	/*
		PartialUpdateProject Update Project
		Update the project and its metadata.
		- Update project name
		- Update project labels
		- Update project parent (folder or organization)

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Project identifier - containerId as well as UUID identifier is supported.
		@return ApiPartialUpdateProjectRequest
	*/
	PartialUpdateProject(ctx context.Context, id string) ApiPartialUpdateProjectRequest
	/*
		PartialUpdateProjectExecute executes the request

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id Project identifier - containerId as well as UUID identifier is supported.
		@return Project

	*/
	PartialUpdateProjectExecute(ctx context.Context, id string) (*Project, error)
}

type ApiCreateFolderRequest interface {
	CreateFolderPayload(createFolderPayload CreateFolderPayload) ApiCreateFolderRequest
	Execute() (*FolderResponse, error)
}

type ApiCreateProjectRequest interface {
	CreateProjectPayload(createProjectPayload CreateProjectPayload) ApiCreateProjectRequest
	Execute() (*Project, error)
}

type ApiDeleteFolderRequest interface {
	// If true, all nested, empty folders are deleted recursively - if no project is attached!
	Force(force bool) ApiDeleteFolderRequest
	Execute() error
}

type ApiDeleteFolderLabelsRequest interface {
	// Label name.
	Keys(keys []string) ApiDeleteFolderLabelsRequest
	Execute() error
}

type ApiDeleteOrganizationLabelsRequest interface {
	// Label name.
	Keys(keys []string) ApiDeleteOrganizationLabelsRequest
	Execute() error
}

type ApiDeleteProjectRequest interface {
	Execute() error
}

type ApiDeleteProjectLabelsRequest interface {
	// Label name.
	Keys(keys []string) ApiDeleteProjectLabelsRequest
	Execute() error
}

type ApiGetFolderDetailsRequest interface {
	IncludeParents(includeParents bool) ApiGetFolderDetailsRequest
	Execute() (*GetFolderDetailsResponse, error)
}

type ApiGetOrganizationRequest interface {
	Execute() (*OrganizationResponse, error)
}

type ApiGetProjectRequest interface {
	IncludeParents(includeParents bool) ApiGetProjectRequest
	Execute() (*GetProjectResponse, error)
}

type ApiListFoldersRequest interface {
	// Identifier of the parent resource container - containerId as well as UUID identifier is supported.
	ContainerParentId(containerParentId string) ApiListFoldersRequest
	// List of container identifiers - containerId as well as UUID identifier is supported.
	ContainerIds(containerIds []string) ApiListFoldersRequest
	// E-Mail address of the user for whom the visible resource containers should be filtered.
	Member(member string) ApiListFoldersRequest
	// The maximum number of projects to return in the response. If not present, an appropriate default will be used. If maximum is exceeded, maximum is used.
	Limit(limit float32) ApiListFoldersRequest
	// The offset of the first item in the collection to return.
	Offset(offset float32) ApiListFoldersRequest
	// A timestamp to specify the beginning of the creationTime from which entries should be returned. If not given, defaults to the beginning of time.
	CreationTimeStart(creationTimeStart time.Time) ApiListFoldersRequest
	Execute() (*ListFoldersResponse, error)
}

type ApiListOrganizationsRequest interface {
	// Organization identifiers - containerId as well as UUID identifier is supported. A combination of both is not allowed.
	ContainerIds(containerIds []string) ApiListOrganizationsRequest
	// E-Mail address of the user for whom the visible resource containers should be filtered.
	Member(member string) ApiListOrganizationsRequest
	// The maximum number of projects to return in the response. If not present, an appropriate default will be used. If maximum is exceeded, maximum is used.
	Limit(limit float32) ApiListOrganizationsRequest
	// The offset of the first item in the collection to return.
	Offset(offset float32) ApiListOrganizationsRequest
	// A timestamp to specify the beginning of the creationTime from which entries should be returned. If not given, defaults to the beginning of time.
	CreationTimeStart(creationTimeStart time.Time) ApiListOrganizationsRequest
	Execute() (*ListOrganizationsResponse, error)
}

type ApiListProjectsRequest interface {
	// Identifier of the parent resource container - containerId as well as UUID identifier is supported.
	ContainerParentId(containerParentId string) ApiListProjectsRequest
	// List of container identifiers - containerId as well as UUID identifier is supported.
	ContainerIds(containerIds []string) ApiListProjectsRequest
	// E-Mail address of the user for whom the visible resource containers should be filtered.
	Member(member string) ApiListProjectsRequest
	// The offset of the first item in the collection to return.
	Offset(offset float32) ApiListProjectsRequest
	// The maximum number of projects to return in the response. If not present, an appropriate default will be used. If maximum is exceeded, maximum is used.
	Limit(limit float32) ApiListProjectsRequest
	// A timestamp to specify the beginning of the creationTime from which entries should be returned. If not given, defaults to the beginning of time.
	CreationTimeStart(creationTimeStart time.Time) ApiListProjectsRequest
	Execute() (*ListProjectsResponse, error)
}

type ApiPartialUpdateFolderRequest interface {
	PartialUpdateFolderPayload(partialUpdateFolderPayload PartialUpdateFolderPayload) ApiPartialUpdateFolderRequest
	Execute() (*FolderResponse, error)
}

type ApiPartialUpdateOrganizationRequest interface {
	PartialUpdateOrganizationPayload(partialUpdateOrganizationPayload PartialUpdateOrganizationPayload) ApiPartialUpdateOrganizationRequest
	Execute() (*OrganizationResponse, error)
}

type ApiPartialUpdateProjectRequest interface {
	PartialUpdateProjectPayload(partialUpdateProjectPayload PartialUpdateProjectPayload) ApiPartialUpdateProjectRequest
	Execute() (*Project, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type CreateFolderRequest struct {
	ctx                 context.Context
	apiService          *DefaultApiService
	createFolderPayload *CreateFolderPayload
}

func (r CreateFolderRequest) CreateFolderPayload(createFolderPayload CreateFolderPayload) ApiCreateFolderRequest {
	r.createFolderPayload = &createFolderPayload
	return r
}

func (r CreateFolderRequest) Execute() (*FolderResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FolderResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateFolder")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/folders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFolderPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateFolder: Create Folder

Create a new folder.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateFolderRequest
*/
func (a *APIClient) CreateFolder(ctx context.Context) ApiCreateFolderRequest {
	return CreateFolderRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
}

func (a *APIClient) CreateFolderExecute(ctx context.Context) (*FolderResponse, error) {
	r := CreateFolderRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
	return r.Execute()
}

type CreateProjectRequest struct {
	ctx                  context.Context
	apiService           *DefaultApiService
	createProjectPayload *CreateProjectPayload
}

func (r CreateProjectRequest) CreateProjectPayload(createProjectPayload CreateProjectPayload) ApiCreateProjectRequest {
	r.createProjectPayload = &createProjectPayload
	return r
}

func (r CreateProjectRequest) Execute() (*Project, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Project
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateProject")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createProjectPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
CreateProject: Create Project

Create a new project.
- The request is synchronous, but the workflow-based creation is asynchronous.
- Lifecycle state remains in CREATING, until workflow completes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateProjectRequest
*/
func (a *APIClient) CreateProject(ctx context.Context) ApiCreateProjectRequest {
	return CreateProjectRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
}

func (a *APIClient) CreateProjectExecute(ctx context.Context) (*Project, error) {
	r := CreateProjectRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
	return r.Execute()
}

type DeleteFolderRequest struct {
	ctx         context.Context
	apiService  *DefaultApiService
	containerId string
	force       *bool
}

// If true, all nested, empty folders are deleted recursively - if no project is attached!

func (r DeleteFolderRequest) Force(force bool) ApiDeleteFolderRequest {
	r.force = &force
	return r
}

func (r DeleteFolderRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteFolder")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/folders/{containerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"containerId"+"}", url.PathEscape(ParameterValueToString(r.containerId, "containerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
DeleteFolder: Delete Folder

Delete a folder and its metadata.
- Folder must not be parent of any other container
- A force flag may be set, deleting all underlying folders recursively - if no project is attached!

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param containerId Folder identifier - containerId as well as UUID identifier is supported.
	@return ApiDeleteFolderRequest
*/
func (a *APIClient) DeleteFolder(ctx context.Context, containerId string) ApiDeleteFolderRequest {
	return DeleteFolderRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		containerId: containerId,
	}
}

func (a *APIClient) DeleteFolderExecute(ctx context.Context, containerId string) error {
	r := DeleteFolderRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		containerId: containerId,
	}
	return r.Execute()
}

type DeleteFolderLabelsRequest struct {
	ctx         context.Context
	apiService  *DefaultApiService
	containerId string
	keys        *[]string
}

// Label name.

func (r DeleteFolderLabelsRequest) Keys(keys []string) ApiDeleteFolderLabelsRequest {
	r.keys = &keys
	return r
}

func (r DeleteFolderLabelsRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteFolderLabels")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/folders/{containerId}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"containerId"+"}", url.PathEscape(ParameterValueToString(r.containerId, "containerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.keys != nil {
		t := *r.keys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "keys", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "keys", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
DeleteFolderLabels: Delete Folder Labels

Deletes all folder labels by given keys.
- Specific labels may be deleted by key(s)
- If no key is specified, all labels will be deleted!

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param containerId Folder identifier - containerId as well as UUID identifier is supported.
	@return ApiDeleteFolderLabelsRequest
*/
func (a *APIClient) DeleteFolderLabels(ctx context.Context, containerId string) ApiDeleteFolderLabelsRequest {
	return DeleteFolderLabelsRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		containerId: containerId,
	}
}

func (a *APIClient) DeleteFolderLabelsExecute(ctx context.Context, containerId string) error {
	r := DeleteFolderLabelsRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		containerId: containerId,
	}
	return r.Execute()
}

type DeleteOrganizationLabelsRequest struct {
	ctx         context.Context
	apiService  *DefaultApiService
	containerId string
	keys        *[]string
}

// Label name.

func (r DeleteOrganizationLabelsRequest) Keys(keys []string) ApiDeleteOrganizationLabelsRequest {
	r.keys = &keys
	return r
}

func (r DeleteOrganizationLabelsRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteOrganizationLabels")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/organizations/{containerId}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"containerId"+"}", url.PathEscape(ParameterValueToString(r.containerId, "containerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.keys != nil {
		t := *r.keys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "keys", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "keys", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
DeleteOrganizationLabels: Delete Organization Labels

Deletes all organization labels by given keys.
- Specific labels may be deleted by key(s)
- If no key is specified, all labels will be deleted!

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param containerId Organization identifier - containerId as well as UUID identifier is supported.
	@return ApiDeleteOrganizationLabelsRequest
*/
func (a *APIClient) DeleteOrganizationLabels(ctx context.Context, containerId string) ApiDeleteOrganizationLabelsRequest {
	return DeleteOrganizationLabelsRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		containerId: containerId,
	}
}

func (a *APIClient) DeleteOrganizationLabelsExecute(ctx context.Context, containerId string) error {
	r := DeleteOrganizationLabelsRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		containerId: containerId,
	}
	return r.Execute()
}

type DeleteProjectRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	id         string
}

func (r DeleteProjectRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteProject")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
DeleteProject: Delete Project

Triggers the deletion of a project.
- The request is synchronous, but the workflow-based deletion is asynchronous
- Lifecycle state remains in DELETING, until workflow completes

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Project identifier - containerId as well as UUID identifier is supported.
	@return ApiDeleteProjectRequest
*/
func (a *APIClient) DeleteProject(ctx context.Context, id string) ApiDeleteProjectRequest {
	return DeleteProjectRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		id:         id,
	}
}

func (a *APIClient) DeleteProjectExecute(ctx context.Context, id string) error {
	r := DeleteProjectRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		id:         id,
	}
	return r.Execute()
}

type DeleteProjectLabelsRequest struct {
	ctx         context.Context
	apiService  *DefaultApiService
	containerId string
	keys        *[]string
}

// Label name.

func (r DeleteProjectLabelsRequest) Keys(keys []string) ApiDeleteProjectLabelsRequest {
	r.keys = &keys
	return r
}

func (r DeleteProjectLabelsRequest) Execute() error {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteProjectLabels")
	if err != nil {
		return &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{containerId}/labels"
	localVarPath = strings.Replace(localVarPath, "{"+"containerId"+"}", url.PathEscape(ParameterValueToString(r.containerId, "containerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.keys != nil {
		t := *r.keys
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "keys", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "keys", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return newErr
	}

	return nil
}

/*
DeleteProjectLabels: Delete Project Labels

Deletes all project labels by given keys.
- Specific labels may be deleted by key(s)
- If no key is specified, all labels will be deleted!

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param containerId Project identifier - containerId as well as UUID identifier is supported.
	@return ApiDeleteProjectLabelsRequest
*/
func (a *APIClient) DeleteProjectLabels(ctx context.Context, containerId string) ApiDeleteProjectLabelsRequest {
	return DeleteProjectLabelsRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		containerId: containerId,
	}
}

func (a *APIClient) DeleteProjectLabelsExecute(ctx context.Context, containerId string) error {
	r := DeleteProjectLabelsRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		containerId: containerId,
	}
	return r.Execute()
}

type GetFolderDetailsRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	containerId    string
	includeParents *bool
}

func (r GetFolderDetailsRequest) IncludeParents(includeParents bool) ApiGetFolderDetailsRequest {
	r.includeParents = &includeParents
	return r
}

func (r GetFolderDetailsRequest) Execute() (*GetFolderDetailsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetFolderDetailsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetFolderDetails")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/folders/{containerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"containerId"+"}", url.PathEscape(ParameterValueToString(r.containerId, "containerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeParents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeParents", r.includeParents, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetFolderDetails: Get Folder Details

Returns all metadata for a specific folder.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param containerId Folder identifier - containerId as well as UUID identifier is supported.
	@return ApiGetFolderDetailsRequest
*/
func (a *APIClient) GetFolderDetails(ctx context.Context, containerId string) ApiGetFolderDetailsRequest {
	return GetFolderDetailsRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		containerId: containerId,
	}
}

func (a *APIClient) GetFolderDetailsExecute(ctx context.Context, containerId string) (*GetFolderDetailsResponse, error) {
	r := GetFolderDetailsRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		containerId: containerId,
	}
	return r.Execute()
}

type GetOrganizationRequest struct {
	ctx        context.Context
	apiService *DefaultApiService
	id         string
}

func (r GetOrganizationRequest) Execute() (*OrganizationResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OrganizationResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetOrganization")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/organizations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetOrganization: Get Organization Details

Returns the organization and its metadata.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Organization identifier - containerId as well as UUID identifier is supported.
	@return ApiGetOrganizationRequest
*/
func (a *APIClient) GetOrganization(ctx context.Context, id string) ApiGetOrganizationRequest {
	return GetOrganizationRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		id:         id,
	}
}

func (a *APIClient) GetOrganizationExecute(ctx context.Context, id string) (*OrganizationResponse, error) {
	r := GetOrganizationRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		id:         id,
	}
	return r.Execute()
}

type GetProjectRequest struct {
	ctx            context.Context
	apiService     *DefaultApiService
	id             string
	includeParents *bool
}

func (r GetProjectRequest) IncludeParents(includeParents bool) ApiGetProjectRequest {
	r.includeParents = &includeParents
	return r
}

func (r GetProjectRequest) Execute() (*GetProjectResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetProjectResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.GetProject")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeParents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeParents", r.includeParents, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
GetProject: Get Project Details

Returns the project and its metadata.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Project identifier - containerId as well as UUID identifier is supported.
	@return ApiGetProjectRequest
*/
func (a *APIClient) GetProject(ctx context.Context, id string) ApiGetProjectRequest {
	return GetProjectRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		id:         id,
	}
}

func (a *APIClient) GetProjectExecute(ctx context.Context, id string) (*GetProjectResponse, error) {
	r := GetProjectRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		id:         id,
	}
	return r.Execute()
}

type ListFoldersRequest struct {
	ctx               context.Context
	apiService        *DefaultApiService
	containerParentId *string
	containerIds      *[]string
	member            *string
	limit             *float32
	offset            *float32
	creationTimeStart *time.Time
}

// Identifier of the parent resource container - containerId as well as UUID identifier is supported.

func (r ListFoldersRequest) ContainerParentId(containerParentId string) ApiListFoldersRequest {
	r.containerParentId = &containerParentId
	return r
}

// List of container identifiers - containerId as well as UUID identifier is supported.

func (r ListFoldersRequest) ContainerIds(containerIds []string) ApiListFoldersRequest {
	r.containerIds = &containerIds
	return r
}

// E-Mail address of the user for whom the visible resource containers should be filtered.

func (r ListFoldersRequest) Member(member string) ApiListFoldersRequest {
	r.member = &member
	return r
}

// The maximum number of projects to return in the response. If not present, an appropriate default will be used. If maximum is exceeded, maximum is used.

func (r ListFoldersRequest) Limit(limit float32) ApiListFoldersRequest {
	r.limit = &limit
	return r
}

// The offset of the first item in the collection to return.

func (r ListFoldersRequest) Offset(offset float32) ApiListFoldersRequest {
	r.offset = &offset
	return r
}

// A timestamp to specify the beginning of the creationTime from which entries should be returned. If not given, defaults to the beginning of time.

func (r ListFoldersRequest) CreationTimeStart(creationTimeStart time.Time) ApiListFoldersRequest {
	r.creationTimeStart = &creationTimeStart
	return r
}

func (r ListFoldersRequest) Execute() (*ListFoldersResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListFoldersResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListFolders")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/folders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.containerParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "containerParentId", r.containerParentId, "")
	}
	if r.containerIds != nil {
		t := *r.containerIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "containerIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "containerIds", t, "multi")
		}
	}
	if r.member != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "member", r.member, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.creationTimeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creation-time-start", r.creationTimeStart, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListFolders: Get All Folders

Returns all folders and their metadata that:
- Are children of the specific containerParentId
- Match the given containerIds
- User is member of <br />

Filter:
- Either containerParentId OR containerIds OR member must be passed
- If containerId and containerParentId are given, both are used for filtering - containers must point to the same parent
- If member and containerParentId are given, both are used for filtering
- If member is given, containers must not point to the same container parent

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListFoldersRequest
*/
func (a *APIClient) ListFolders(ctx context.Context) ApiListFoldersRequest {
	return ListFoldersRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
}

func (a *APIClient) ListFoldersExecute(ctx context.Context) (*ListFoldersResponse, error) {
	r := ListFoldersRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
	return r.Execute()
}

type ListOrganizationsRequest struct {
	ctx               context.Context
	apiService        *DefaultApiService
	containerIds      *[]string
	member            *string
	limit             *float32
	offset            *float32
	creationTimeStart *time.Time
}

// Organization identifiers - containerId as well as UUID identifier is supported. A combination of both is not allowed.

func (r ListOrganizationsRequest) ContainerIds(containerIds []string) ApiListOrganizationsRequest {
	r.containerIds = &containerIds
	return r
}

// E-Mail address of the user for whom the visible resource containers should be filtered.

func (r ListOrganizationsRequest) Member(member string) ApiListOrganizationsRequest {
	r.member = &member
	return r
}

// The maximum number of projects to return in the response. If not present, an appropriate default will be used. If maximum is exceeded, maximum is used.

func (r ListOrganizationsRequest) Limit(limit float32) ApiListOrganizationsRequest {
	r.limit = &limit
	return r
}

// The offset of the first item in the collection to return.

func (r ListOrganizationsRequest) Offset(offset float32) ApiListOrganizationsRequest {
	r.offset = &offset
	return r
}

// A timestamp to specify the beginning of the creationTime from which entries should be returned. If not given, defaults to the beginning of time.

func (r ListOrganizationsRequest) CreationTimeStart(creationTimeStart time.Time) ApiListOrganizationsRequest {
	r.creationTimeStart = &creationTimeStart
	return r
}

func (r ListOrganizationsRequest) Execute() (*ListOrganizationsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListOrganizationsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListOrganizations")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.containerIds != nil {
		t := *r.containerIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "containerIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "containerIds", t, "multi")
		}
	}
	if r.member != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "member", r.member, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.creationTimeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creation-time-start", r.creationTimeStart, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListOrganizations: Get All Organizations

Returns all organizations and their metadata.
- If no containerIds are specified, all organizations are returned, if permitted
- ContainerIds may be set to filter
- Member may be set to filter
- If member and containerIds are given, both are used for filtering

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListOrganizationsRequest
*/
func (a *APIClient) ListOrganizations(ctx context.Context) ApiListOrganizationsRequest {
	return ListOrganizationsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
}

func (a *APIClient) ListOrganizationsExecute(ctx context.Context) (*ListOrganizationsResponse, error) {
	r := ListOrganizationsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
	return r.Execute()
}

type ListProjectsRequest struct {
	ctx               context.Context
	apiService        *DefaultApiService
	containerParentId *string
	containerIds      *[]string
	member            *string
	offset            *float32
	limit             *float32
	creationTimeStart *time.Time
}

// Identifier of the parent resource container - containerId as well as UUID identifier is supported.

func (r ListProjectsRequest) ContainerParentId(containerParentId string) ApiListProjectsRequest {
	r.containerParentId = &containerParentId
	return r
}

// List of container identifiers - containerId as well as UUID identifier is supported.

func (r ListProjectsRequest) ContainerIds(containerIds []string) ApiListProjectsRequest {
	r.containerIds = &containerIds
	return r
}

// E-Mail address of the user for whom the visible resource containers should be filtered.

func (r ListProjectsRequest) Member(member string) ApiListProjectsRequest {
	r.member = &member
	return r
}

// The offset of the first item in the collection to return.

func (r ListProjectsRequest) Offset(offset float32) ApiListProjectsRequest {
	r.offset = &offset
	return r
}

// The maximum number of projects to return in the response. If not present, an appropriate default will be used. If maximum is exceeded, maximum is used.

func (r ListProjectsRequest) Limit(limit float32) ApiListProjectsRequest {
	r.limit = &limit
	return r
}

// A timestamp to specify the beginning of the creationTime from which entries should be returned. If not given, defaults to the beginning of time.

func (r ListProjectsRequest) CreationTimeStart(creationTimeStart time.Time) ApiListProjectsRequest {
	r.creationTimeStart = &creationTimeStart
	return r
}

func (r ListProjectsRequest) Execute() (*ListProjectsResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListProjectsResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListProjects")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.containerParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "containerParentId", r.containerParentId, "")
	}
	if r.containerIds != nil {
		t := *r.containerIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "containerIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "containerIds", t, "multi")
		}
	}
	if r.member != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "member", r.member, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.creationTimeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "creation-time-start", r.creationTimeStart, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
ListProjects: Get All Projects

Returns all projects and their metadata that:
- Are children of the specific containerParentId
- Match the given containerIds
- User is member of

Filter:
- Either containerParentId OR containerIds OR member must be passed
- If containerId and containerParentId are given, both are used for filtering - containers must point to the same parent
- If member and containerParentId are given, both are used for filtering
- If member is given, containers must not point to the same container parent

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListProjectsRequest
*/
func (a *APIClient) ListProjects(ctx context.Context) ApiListProjectsRequest {
	return ListProjectsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
}

func (a *APIClient) ListProjectsExecute(ctx context.Context) (*ListProjectsResponse, error) {
	r := ListProjectsRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
	}
	return r.Execute()
}

type PartialUpdateFolderRequest struct {
	ctx                        context.Context
	apiService                 *DefaultApiService
	containerId                string
	partialUpdateFolderPayload *PartialUpdateFolderPayload
}

func (r PartialUpdateFolderRequest) PartialUpdateFolderPayload(partialUpdateFolderPayload PartialUpdateFolderPayload) ApiPartialUpdateFolderRequest {
	r.partialUpdateFolderPayload = &partialUpdateFolderPayload
	return r
}

func (r PartialUpdateFolderRequest) Execute() (*FolderResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FolderResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PartialUpdateFolder")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/folders/{containerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"containerId"+"}", url.PathEscape(ParameterValueToString(r.containerId, "containerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partialUpdateFolderPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
PartialUpdateFolder: Update Folder

Update the folder and its metadata.
- Update folder name
- Update folder labels
- Update folder parent (folder or organization)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param containerId Folder identifier - containerId as well as UUID identifier is supported.
	@return ApiPartialUpdateFolderRequest
*/
func (a *APIClient) PartialUpdateFolder(ctx context.Context, containerId string) ApiPartialUpdateFolderRequest {
	return PartialUpdateFolderRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		containerId: containerId,
	}
}

func (a *APIClient) PartialUpdateFolderExecute(ctx context.Context, containerId string) (*FolderResponse, error) {
	r := PartialUpdateFolderRequest{
		apiService:  a.defaultApi,
		ctx:         ctx,
		containerId: containerId,
	}
	return r.Execute()
}

type PartialUpdateOrganizationRequest struct {
	ctx                              context.Context
	apiService                       *DefaultApiService
	id                               string
	partialUpdateOrganizationPayload *PartialUpdateOrganizationPayload
}

func (r PartialUpdateOrganizationRequest) PartialUpdateOrganizationPayload(partialUpdateOrganizationPayload PartialUpdateOrganizationPayload) ApiPartialUpdateOrganizationRequest {
	r.partialUpdateOrganizationPayload = &partialUpdateOrganizationPayload
	return r
}

func (r PartialUpdateOrganizationRequest) Execute() (*OrganizationResponse, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *OrganizationResponse
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PartialUpdateOrganization")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/organizations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partialUpdateOrganizationPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
PartialUpdateOrganization: Update Organization

Update the organization and its metadata.
- Update organization name
- Update organization labels

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Organization identifier - containerId as well as UUID identifier is supported.
	@return ApiPartialUpdateOrganizationRequest
*/
func (a *APIClient) PartialUpdateOrganization(ctx context.Context, id string) ApiPartialUpdateOrganizationRequest {
	return PartialUpdateOrganizationRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		id:         id,
	}
}

func (a *APIClient) PartialUpdateOrganizationExecute(ctx context.Context, id string) (*OrganizationResponse, error) {
	r := PartialUpdateOrganizationRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		id:         id,
	}
	return r.Execute()
}

type PartialUpdateProjectRequest struct {
	ctx                         context.Context
	apiService                  *DefaultApiService
	id                          string
	partialUpdateProjectPayload *PartialUpdateProjectPayload
}

func (r PartialUpdateProjectRequest) PartialUpdateProjectPayload(partialUpdateProjectPayload PartialUpdateProjectPayload) ApiPartialUpdateProjectRequest {
	r.partialUpdateProjectPayload = &partialUpdateProjectPayload
	return r
}

func (r PartialUpdateProjectRequest) Execute() (*Project, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Project
	)
	a := r.apiService
	client, ok := a.client.(*APIClient)
	if !ok {
		return localVarReturnValue, fmt.Errorf("could not parse client to type APIClient")
	}
	localBasePath, err := client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.PartialUpdateProject")
	if err != nil {
		return localVarReturnValue, &oapierror.GenericOpenAPIError{ErrorMessage: err.Error()}
	}

	localVarPath := localBasePath + "/v2/projects/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(ParameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partialUpdateProjectPayload
	req, err := client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, err
	}

	contextHTTPRequest, ok := r.ctx.Value(config.ContextHTTPRequest).(**http.Request)
	if ok {
		*contextHTTPRequest = req
	}

	localVarHTTPResponse, err := client.callAPI(req)
	contextHTTPResponse, ok := r.ctx.Value(config.ContextHTTPResponse).(**http.Response)
	if ok {
		*contextHTTPResponse = localVarHTTPResponse
	}
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
			return localVarReturnValue, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponse
			err = client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.ErrorMessage = err.Error()
				return localVarReturnValue, newErr
			}
			newErr.ErrorMessage = oapierror.FormatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.Model = v
		}
		return localVarReturnValue, newErr
	}

	err = client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &oapierror.GenericOpenAPIError{
			StatusCode:   localVarHTTPResponse.StatusCode,
			Body:         localVarBody,
			ErrorMessage: err.Error(),
		}
		return localVarReturnValue, newErr
	}

	return localVarReturnValue, nil
}

/*
PartialUpdateProject: Update Project

Update the project and its metadata.
- Update project name
- Update project labels
- Update project parent (folder or organization)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id Project identifier - containerId as well as UUID identifier is supported.
	@return ApiPartialUpdateProjectRequest
*/
func (a *APIClient) PartialUpdateProject(ctx context.Context, id string) ApiPartialUpdateProjectRequest {
	return PartialUpdateProjectRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		id:         id,
	}
}

func (a *APIClient) PartialUpdateProjectExecute(ctx context.Context, id string) (*Project, error) {
	r := PartialUpdateProjectRequest{
		apiService: a.defaultApi,
		ctx:        ctx,
		id:         id,
	}
	return r.Execute()
}
